Charpter 1: Overview
==================================================
Portal Framework
    Components

EBusiness Services
    Content Management
    Content caching
    Web Publishing
    Workflow
    Personalization
    User Profiling
    Rules Engine
    XML Integration
    Single Sign On
    Search Engine

JavaEE Server
    Presentation
    Business Logic
    Transaction
    Messaging
    Scalability
    Reliability
    Security
    Management

Charpter 2: Architecture and Protocols
==================================================
Non-functional Requirements:
  Time:
      Performance
      Reliability
  Space:
      Scalability
      Extensibility
      Portability
  CostOfUse:
      Maintainability
      Availability
      Manageability
      Testability
      Flexibility
  Security
      Security

Architect's role:
  Architects visualize the behavior of a system. 
  Architects create the BluePrint for the system, 
  Architects define the way in which the elements of the system work together. 
  Architects distinguish between functional and nonfunctional system requirements, 
  Architects are responsible for integrating nonfunctional requirements into the system.

Types of Architecture:
  Architecture refers to an abstract representation of a system¡¯s components and behaviors. Architecture satisfies the functional and nonfunctional requirements of the client and is flexible enough to evolve when the requirements change.

  System Architecture:
    System architecture must consider the functions of components, their interfaces, interactions, and constraints


Steps in Software Development
  requirement analysis 
    The requirement analysis describes what the system should do. 
    Analysts generate domain models:classes, objects, and interactions. 
    The requirement analysis should theoretically be free from any technical or implementation details and should contain an ideal model

  object-oriented analysis
    This phase involves the analysis of the domain. The analysts would do the following:
      Develop use case diagrams for all the business processes. Use case diagrams are high-level descriptions of the system actors and the system functionality.
      Develop sequence diagrams. These diagrams show the sequence of operation as a function of time.
      Develop class diagrams. Class diagrams show the system functionality as classes and their methods.
      Develop collaboration diagrams. Collaboration diagrams depict how the classes interact.

  architectural analysis, 
    This phase tries to give a framework within which all the components will work to satisfy all the customer requirements.
    Pragmatically, the architect would work out a solution that takes into account security, performance, and cost, as well as considers reusing existing technology and business logic in the legacy system.
    From the object-oriented design perspective, the architect would do the following:
     Develop package dependency diagrams.
     Decide how the classes in different packages interact.
     Develop deployment diagrams.
     Decide where the software components will reside in deployment.

  object-oriented design 
    In this phase, the design for the implementation is complete, and the decision is made.
    All the classes are defined with their intended directory hierarchies identified. 
    Design patterns are used, and object reuse is considered. 
    Any architectural considerations arising out of the implementation design are discussed.

Architectural Terminology
  
Principles of Architecture
  Layering (Page 37)
  ...

Capabilities and System Quality

  System Quality	Definition
  -----------------------------------------------------
  Availability 	The degree to which a system is accessible. The term 24¡Á7 describes total availability. This aspect of a system is often coupled with performance.
  Reliability 	The ability to ensure the integrity and consistency of an application and its transactions.
  Manageability 	The ability to administer and thereby manage the system resources to ensure the availability and performance of a system with respect to the other capabilities.
  Flexibility 	The ability to address architectural and hardware configuration changes without a great deal of impact to the underlying system.
  Performance 	The ability to carry out functionality in a timeframe that meets specified goals.
  Capacity 		The ability of a system to run multiple tasks per unit of time.
  Scalability 	The ability to support the required availability and performance as transactional load increases.
  Extensibility 	The ability to extend functionality.
  Validity 		The ability to predict and confirm results based on a specified input or user gesture.
  Reusability 	The ability to use a component in more than one context without changing its internals.
  Security 		The ability to ensure that information is not accessed and modified unless done so in accordance with the enterprise policy.


Security
  Single Sing On requires a rich infrastructure of network and system services.
  The classes of threats includes 
      accidental threats, 
      intentional threats, 
      passive threats (those that do not change the state of the system but may include loss of confidentiality), 
      active threats (those that change the state of the system, including changes to data and to software).
  A security policy is an enterprise¡¯s statement defining the rules that regulate how it will provide security, handle intrusions, and recover from damage caused by security breaches
  A standard set of Security services includes the following:
      Identification and authentication 
      Access control and authorization 
      Accountability and auditing 
      Data confidentiality 
      Data integrity and recovery
      Data exchange 
      Object reuse 
      Non-repudiation of origin and delivery 
      Reliability

Creating an Architecture Using Distributed Services and JEE
    Industry experience shows that integrating legacy resources can take up to 50 percent of application development time.
    
Enterprise JavaBeans
Distributed Application Lifecycle
Iterative Development/MVC
Simplifi ed Architecture and Development
Component-Based Application Models
JEE APIs and Certification
XML and JEE















